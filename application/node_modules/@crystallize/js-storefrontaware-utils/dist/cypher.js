"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cypher = exports.decryptValue = exports.encryptValue = void 0;
const crypto_1 = __importDefault(require("crypto"));
function encryptValue(value, secretKey, algorithm) {
    const initVector = crypto_1.default.randomBytes(16);
    const cipher = crypto_1.default.createCipheriv(algorithm, secretKey, initVector);
    let encryptedData = cipher.update(value, 'utf-8', 'hex');
    encryptedData += cipher.final('hex');
    return `${initVector.toString('hex')}:${encryptedData}`;
}
exports.encryptValue = encryptValue;
function decryptValue(value, secretKey, algorithm) {
    if (value?.includes(':')) {
        const [initVector, encryptedData] = value.split(':');
        const decipher = crypto_1.default.createDecipheriv(algorithm, secretKey, Buffer.from(initVector, 'hex'));
        let decryptedData = decipher.update(encryptedData, 'hex', 'utf-8');
        decryptedData += decipher.final('utf8');
        return decryptedData;
    }
    return value || '';
}
exports.decryptValue = decryptValue;
/**
 * Create encrypt/decrypt/decryptMape methods based on supplied escret
 */
const cypher = (secret) => {
    const key = crypto_1.default.createHash('sha256').update(String(secret)).digest('base64').substring(0, 32);
    const algorithm = 'aes-256-cbc';
    const encrypt = (value) => encryptValue(value, key, algorithm);
    const decrypt = (value) => decryptValue(value, key, algorithm);
    return {
        encrypt,
        decrypt,
        decryptMap: (map) => {
            let result = {};
            Object.keys(map).forEach((key) => {
                result = {
                    ...result,
                    [key]: decrypt(map[key]),
                };
            });
            return result;
        },
    };
};
exports.cypher = cypher;
//# sourceMappingURL=cypher.js.map